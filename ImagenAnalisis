const ColorAnalyzer = () => {
  const [colorReport, setColorReport] = useState(null);
  const [imageUrl, setImageUrl] = useState(null);
  const [tolerance, setTolerance] = useState(75); // Increased default tolerance
  const [rawColorCounts, setRawColorCounts] = useState(null);
  const canvasRef = useRef(null);
  const fileInputRef = useRef(null);

  // Enhanced color distance calculation using LAB color space for better perceptual difference
  const rgbToLab = (r, g, b) => {
    // Convert RGB to XYZ
    r = r / 255;
    g = g / 255;
    b = b / 255;

    r = r > 0.04045 ? Math.pow((r + 0.055) / 1.055, 2.4) : r / 12.92;
    g = g > 0.04045 ? Math.pow((g + 0.055) / 1.055, 2.4) : g / 12.92;
    b = b > 0.04045 ? Math.pow((b + 0.055) / 1.055, 2.4) : b / 12.92;

    r *= 100;
    g *= 100;
    b *= 100;

    const x = r * 0.4124 + g * 0.3576 + b * 0.1805;
    const y = r * 0.2126 + g * 0.7152 + b * 0.0722;
    const z = r * 0.0193 + g * 0.1192 + b * 0.9505;

    // Convert XYZ to Lab
    const xn = 95.047;
    const yn = 100.000;
    const zn = 108.883;

    const xx = x / xn;
    const yy = y / yn;
    const zz = z / zn;

    const fx = xx > 0.008856 ? Math.pow(xx, 1/3) : (7.787 * xx) + 16/116;
    const fy = yy > 0.008856 ? Math.pow(yy, 1/3) : (7.787 * yy) + 16/116;
    const fz = zz > 0.008856 ? Math.pow(zz, 1/3) : (7.787 * zz) + 16/116;

    const l = (116 * fy) - 16;
    const a = 500 * (fx - fy);
    const b_val = 200 * (fy - fz);

    return [l, a, b_val];
  };

  const getColorDistance = (hex1, hex2) => {
    const r1 = parseInt(hex1.slice(1, 3), 16);
    const g1 = parseInt(hex1.slice(3, 5), 16);
    const b1 = parseInt(hex1.slice(5, 7), 16);
    
    const r2 = parseInt(hex2.slice(1, 3), 16);
    const g2 = parseInt(hex2.slice(3, 5), 16);
    const b2 = parseInt(hex2.slice(5, 7), 16);
    
    const lab1 = rgbToLab(r1, g1, b1);
    const lab2 = rgbToLab(r2, g2, b2);
    
    // Calculate delta E (CIE76)
    return Math.sqrt(
      Math.pow(lab1[0] - lab2[0], 2) +
      Math.pow(lab1[1] - lab2[1], 2) +
      Math.pow(lab1[2] - lab2[2], 2)
    );
  };

  // Modified merge function with enhanced separation
  const mergeSimilarColors = (colors, tolerance) => {
    const mergedColors = {};
    const scaledTolerance = tolerance * 1.5; // Increase separation threshold
    
    Object.entries(colors).forEach(([color, count]) => {
      let foundSimilar = false;
      
      for (const [existingColor, existingCount] of Object.entries(mergedColors)) {
        if (getColorDistance(color, existingColor) < scaledTolerance) {
          // Use dominant color instead of average for more distinct results
          const totalCount = count + existingCount;
          const dominantColor = count > existingCount ? color : existingColor;
          
          delete mergedColors[existingColor];
          mergedColors[dominantColor] = totalCount;
          foundSimilar = true;
          break;
        }
      }
      
      if (!foundSimilar) {
        mergedColors[color] = count;
      }
    });
    
    return mergedColors;
  };

  const processImage = (file) => {
    const reader = new FileReader();
    reader.onload = (e) => {
      const img = new Image();
      img.onload = () => {
        const canvas = canvasRef.current;
        const ctx = canvas.getContext('2d');
        
        // Scale down large images for better performance
        const maxDim = 800;
        let width = img.width;
        let height = img.height;
        
        if (width > maxDim || height > maxDim) {
          if (width > height) {
            height = (height / width) * maxDim;
            width = maxDim;
          } else {
            width = (width / height) * maxDim;
            height = maxDim;
          }
        }
        
        canvas.width = width;
        canvas.height = height;
        ctx.drawImage(img, 0, 0, width, height);
        
        const imageData = ctx.getImageData(0, 0, width, height);
        const colorCounts = {};
        
        // Sample pixels for better performance on large images
        const samplingRate = Math.ceil(imageData.data.length / (4 * 100000)); // Sample to get ~100k pixels
        
        for (let i = 0; i < imageData.data.length; i += 4 * samplingRate) {
          const r = imageData.data[i];
          const g = imageData.data[i + 1];
          const b = imageData.data[i + 2];
          const hex = rgbToHex(r, g, b);
          colorCounts[hex] = (colorCounts[hex] || 0) + 1;
        }
        
        setRawColorCounts(colorCounts);
        setImageUrl(e.target.result);
        processColors(colorCounts, tolerance);
      };
      img.src = e.target.result;
    };
    reader.readAsDataURL(file);
  };

  const processColors = (colorCounts, toleranceValue) => {
    const mergedColors = mergeSimilarColors(colorCounts, toleranceValue);
    
    const sortedColors = Object.entries(mergedColors)
      .sort(([, a], [, b]) => b - a)
      .slice(0, 6)
      .map(([color, count]) => ({
        hex: color,
        count,
        percentage: ((count / Object.values(mergedColors).reduce((a, b) => a + b, 0)) * 100).toFixed(2)
      }));
    
    setColorReport(sortedColors);
  };

  useEffect(() => {
    if (rawColorCounts) {
      processColors(rawColorCounts, tolerance);
    }
  }, [tolerance, rawColorCounts]);

  const rgbToHex = (r, g, b) => {
    return '#' + [r, g, b].map(x => {
      const hex = x.toString(16);
      return hex.length === 1 ? '0' + hex : hex;
    }).join('');
  };

  const handleDrop = (e) => {
    e.preventDefault();
    const file = e.dataTransfer.files[0];
    if (file && file.type.startsWith('image/')) {
      processImage(file);
    }
  };

  const handleDragOver = (e) => {
    e.preventDefault();
  };

  const downloadReport = () => {
    if (!colorReport) return;
    
    const reportText = colorReport
      .map((color, i) => `${i + 1}. ${color.hex} - ${color.percentage}%`)
      .join('\n');
    
    const blob = new Blob([reportText], { type: 'text/plain' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'color-report.txt';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  };

  const downloadColorCubes = () => {
    if (!colorReport) return;

    const svgString = `
      <svg xmlns="http://www.w3.org/2000/svg" viewBox="0 0 150 50">
        ${colorReport.map((color, i) => `
          <rect
            x="${i * 25}"
            y="0"
            width="20"
            height="20"
            fill="${color.hex}"
            stroke="white"
            stroke-width="0.5"
          />
        `).join('')}
      </svg>
    `;

    const blob = new Blob([svgString], { type: 'image/svg+xml' });
    const url = URL.createObjectURL(blob);
    const a = document.createElement('a');
    a.href = url;
    a.download = 'color-cubes.svg';
    document.body.appendChild(a);
    a.click();
    document.body.removeChild(a);
    URL.revokeObjectURL(url);
  };

  return (
    <div className="w-full max-w-4xl mx-auto p-4">
      <Card>
        <CardHeader>
          <CardTitle>Image Color Analyzer</CardTitle>
        </CardHeader>
        <CardContent>
          <div 
            className="border-2 border-dashed border-gray-300 rounded-lg p-8 text-center mb-4"
            onDrop={handleDrop}
            onDragOver={handleDragOver}
          >
            <input
              type="file"
              ref={fileInputRef}
              className="hidden"
              accept="image/*"
              onChange={(e) => processImage(e.target.files[0])}
            />
            <Upload className="mx-auto mb-4" size={48} />
            <p>Drag and drop an image here or</p>
            <Button 
              onClick={() => fileInputRef.current.click()}
              className="mt-2"
            >
              Choose File
            </Button>
          </div>

          {imageUrl && (
            <>
              <div className="mb-4">
                <img src={imageUrl} alt="Uploaded" className="max-w-full h-auto" />
              </div>
              
              <div className="mb-6">
                <label className="block text-sm font-medium mb-2">
                  Color Separation: {tolerance}
                </label>
                <Slider
                  value={[tolerance]}
                  onValueChange={([value]) => setTolerance(value)}
                  min={25}
                  max={150}
                  step={1}
                  className="w-full"
                />
                <p className="text-sm text-gray-500 mt-1">
                  Higher values will detect more distinct colors, lower values will find more similar colors
                </p>
              </div>
            </>
          )}

          <canvas ref={canvasRef} className="hidden" />

          {colorReport && (
            <div>
              <h3 className="text-lg font-semibold mb-2">Color Analysis</h3>
              <div className="grid grid-cols-6 gap-2 mb-4">
                {colorReport.map((color, i) => (
                  <div key={i} className="text-center">
                    <div
                      className="w-full aspect-square mb-1 border border-gray-200"
                      style={{ backgroundColor: color.hex }}
                    />
                    <div className="text-sm">{color.hex}</div>
                    <div className="text-xs text-gray-500">{color.percentage}%</div>
                  </div>
                ))}
              </div>
              
              <div className="flex gap-2">
                <Button onClick={downloadReport}>
                  Download Report
                </Button>
                <Button onClick={downloadColorCubes}>
                  Download Color Cubes
                </Button>
              </div>
            </div>
          )}
        </CardContent>
      </Card>
    </div>
  );
};

export default ColorAnalyzer;
